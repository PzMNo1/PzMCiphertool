<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8">
		<title>密码工具箱 | By泡面的面</title>
		<style>
			:root {
				--bg: #1a1a1a;
				--primary: #2ecc71;
				--secondary: #3498db;
				--accent: #9b59b6;
				--text: #ecf0f1;
				--card-bg: #2c3e50;
				--error: #e74c3c;
			}

			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				font-family: 'Segoe UI', system-ui;
			}

			body {
				background: var(--bg);
				color: var(--text);
				line-height: 1.6;
				padding: 2rem;
				min-height: 100vh;
			}

			.container {
				max-width: 1200px;
				margin: 0 auto;
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
				gap: 1.5rem;
			}

			.main-input {
				grid-column: 1/-1;
			}

			

			.card {
				background: var(--card-bg);
				border-radius: 15px;
				padding: 1.5rem;
				box-shadow: 0 10px 20px rgba(0,0,0,0.3);
				transition: transform 0.3s ease;
				position: relative;
			}

			.card:hover {
				transform: translateY(-5px);
			}

			h1 {
				text-align: center;
				margin-bottom: 2rem;
				font-size: 2.5rem;
				text-shadow: 0 2px 4px rgba(0,0,0,0.3);
				background: linear-gradient(45deg, var(--primary), var(--secondary));
				-webkit-background-clip: text;
				background-clip: text; 	/* 添加标准属性 */
				-webkit-text-fill-color: transparent;
			}

			.input-group {
				margin-bottom: 1.5rem;
				position: relative;
			}

			input, textarea, select{
			    width: 100%;
			    padding: 0.8rem;
			    background: rgba(255,255,255,0.1);
			    border: 2px solid transparent;
			    border-radius: 8px;
			    color: var(--text);
			    transition: all 0.3s ease;
			}

			textarea {
				min-height: 120px;
			}

			input:focus, textarea:focus, select:focus {
			    outline: none;
			    border-color: var(--primary);
			    box-shadow: 0 0 10px rgba(46, 204, 113, 0.3);
			}

			.result {
				background: rgba(0,0,0,0.3);
				padding: 1rem;
				border-radius: 8px;
				min-height: 80px;
				white-space: pre-wrap;
				position: relative;
				overflow: hidden;
			}

			.result::after {
				content: "";
				position: absolute;
				top: 0;
				left: -100%;
				width: 100%;
				height: 100%;
				background: linear-gradient(
					90deg,
					transparent,
					rgba(255,255,255,0.1),
					transparent
				);
				animation: shine 1.5s infinite;
			}

			@keyframes shine {
				100% {
					left: 100%;
				}
			}

			.badge {
			    position: absolute;
			    top: -10px;
			    right: -10px;
			    background: var(--accent);
			    color: white;
			    padding: 0.3rem 0.8rem;
			    border-radius: 20px;
			    font-size: 0.8rem;
			    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
			}

			.grid-2 {
			    display: grid;
			    grid-template-columns: 1fr auto;
			    gap: 1rem;
			}

			.grid-3 {
			  display: grid;
			  grid-template-columns: 1fr 1fr 1fr;
			  gap: 0.5rem;
			}

			.grid-full {
			  margin-bottom: 8px;  
			}

			.grid-full2 {
			  margin-top: 8px; 
			  margin-bottom: 8px;  
			}

			option {
			    background: var(--card-bg) !important;
			    color: var(--text) !important;
			    padding: 1.5rem;
			}

			/* 【清空】按钮  */
			.cyber-button {
				--primary-clr: #2ecc71;
				--secondary-clr: #3498db;
				--glow-clr: rgba(46, 204, 113, 0.5);
				
				position: relative;
				display: flex;
				align-items: center;
				justify-content: center;
				min-width: 60px; /* 从80px减小到60px */
				padding: 0.5rem 0.8rem; /* 从0.8rem 1.2rem减小到0.5rem 0.8rem */
				font-size: 0.8rem; /* 从0.9rem减小到0.8rem */
				font-weight: 600;
				letter-spacing: 1px;
				background: transparent;
				border: 2px solid var(--primary-clr);
				border-radius: 6px; /* 从8px减小到6px */
				color: var(--text);
				text-transform: uppercase;
				overflow: hidden;
				cursor: pointer;
				transition: all 0.3s ease;
				z-index: 1;
				box-shadow: 0 0 8px var(--glow-clr), inset 0 0 4px var(--glow-clr); /* 减小阴影 */
			}
			
			.cyber-button:before {
				content: "";
				position: absolute;
				top: 0;
				left: -100%;
				width: 100%;
				height: 100%;
				background: linear-gradient(
					90deg,
					transparent,
					var(--glow-clr),
					transparent
				);
				transition: all 0.6s ease;
				z-index: -1;
			}
			
			.cyber-button:hover {
				box-shadow: 0 0 12px var(--glow-clr), inset 0 0 8px var(--glow-clr); /* 减小悬停阴影 */
				border-color: var(--secondary-clr);
				color: white;
				text-shadow: 0 0 4px white;
				transform: translateY(-2px);
			}
			
			.cyber-button:hover:before {
				left: 100%;
			}
			
			.cyber-button__tag {
				position: relative;
				z-index: 2;
			}
			
			@keyframes glitch {
				0% { clip-path: inset(80% 0 0 0); transform: translate(-2px, 2px); }
				20% { clip-path: inset(0 90% 0 0); transform: translate(2px, -2px); }
				40% { clip-path: inset(0 0 70% 0); transform: translate(2px, 2px); }
				60% { clip-path: inset(0 0 0 80%); transform: translate(-2px, -2px); }
				80% { clip-path: inset(60% 0 0 0); transform: translate(2px, 2px); }
				100% { clip-path: inset(0 0 0 0); transform: translate(0, 0); }
			}
			
			.cyber-button:hover .cyber-button__glitch {
				animation: glitch 0.5s infinite;
			}

		</style>
	</head>

	<body>

		<h1>密码工具箱 | By泡面的面</h1>
		<div class="container">
			<div class="card main-input">
				<div class="badge">输入</div>
				<textarea id="mainInput" placeholder="输入要加密/解密的内容..." autofocus></textarea>
			</div>

			<div class="card">
				<div class="badge">Caesar</div>
				<input type="number" id="caesarShift" placeholder="偏移量" value="3">
				<div class="result" id="caesarResult"></div>
			</div>

			<div class="card">
				<div class="badge">Vigenère</div>
				<input type="text" id="vigenereKey" placeholder="输入密钥">
				<div class="result" id="vigenereResult"></div>
			</div>

			<div class="card">
				<div class="badge">栅栏</div>
				<input type="number" id="railCount" placeholder="层数" value="3">
				<div class="result" id="railResult"></div>
			</div>

			<div class="card">
				<div class="badge">AtBash</div>
				<div class="result" id="atbashResult"></div>
			</div>

		    <!-- Affine -->
			<div class="card">
				<div class="badge">仿射</div>
				<div class="grid-full">
					<input type="text" id="AffineAlpha" placeholder="字母" value="abcdefghijklmnopqrstuvwxyz"></div>
				<div class="grid-2"> 
					<input type="number" id="Affineslope" placeholder="坡度A" value="1">
					<input type="number" id="AffineIntercept" placeholder="截距B" value="1">
				</div>
				<div class="result" id="AffineResult"></div>
			</div>

			<!-- 旗语 -->
			<div class="card">
				<div class="badge">旗语</div>
				<div class="grid-full2">
					<select id="qiyuType">
						<option value="semaphore">旗语 (Semaphore)</option>
						<option value="braille">盲文 (Braille)</option>
					</select>
				</div>
				<div class="grid-full2">
					<input type="text" id="qiyuInput" placeholder="输入字母" value="">
					<button id="qiyuClear" class="cyber-button">
						<span class="cyber-button__glitch"></span>
						<span class="cyber-button__tag">清空</span>
					</button>
				</div>
				<div id="qiyuCanvasContainer" class="input-group" style="display:flex;flex-wrap:wrap;gap:10px;justify-content:center;"></div>
				<div class="result" id="qiyuResult"></div>
			</div>
		</div>
									

		<script>
			const Caesar = { // 凯撒密码
			  e: (t,s) => t.replace(/[a-z]/gi, c=>String.fromCharCode((c.charCodeAt(0)-(c<'a'?65:97)+s+26)%26+(c<'a'?65:97))),
			  d: (t,s) => Caesar.e(t,-s)
			};
			const Vigenere = { // 维吉尼亚密码
			  e: (t,k,mode=1)=>{ let r="",ki=0,K=(k||"KEY").toUpperCase(); for(let c of t){ if(/[a-z]/i.test(c)){ let b=c<'a'?65:97, sh=K[ki % K.length].charCodeAt(0)-65; r+=String.fromCharCode((c.charCodeAt(0)-b+(mode===1?sh:-sh)+26)%26+b); ki++; } else r+=c; } return r; },
			  d: (t,k)=>Vigenere.e(t,k,-1)
			};
			const RailFence = { // 栅栏密码
			  e: (t,r=3)=>{ if(r<2)return ""; t=t.replace(/\s/g,""); let p=2*r-2, res=""; for(let i=0;i<r;i++) for(let j=0;j<t.length;j++) if(j%p==i || j%p==p-i) res+=t[j]; return res; },
			  d: (t,r=3)=>{ if(r<2)return ""; t=t.replace(/\s/g,""); let p=2*r-2, len=t.length, idxs=[]; for(let i=0;i<r;i++) for(let j=0;j<len;j++) if(j%p==i || j%p==p-i) idxs.push(j); idxs.sort((a,b)=>a-b); let arr=[]; for(let i=0;i<len;i++) arr[idxs[i]]=t[i]; return arr.join(''); }
			};
			const AtBash = { // AtBash密码
			  e: t=> t.replace(/[a-z]/gi, c=> String.fromCharCode((c<'a'?90:122)-(c.charCodeAt(0)-(c<'a'?65:97))))
			};
			const Affine = { // 仿射密码
			  modInv: (a,m)=> { a=((a%m)+m)%m; for(let x=1;x<m;x++) if((a*x)%m===1)return x; return null; },
			  e: (t,alpha,a,b)=>{ let m=alpha.length, r=""; for(let c of t){ let i=alpha.indexOf(c.toLowerCase()); if(i===-1) r+=c; else { let j = ((a*i+b)%m+m)%m; r+= c===c.toUpperCase()? alpha[j].toUpperCase() : alpha[j]; } } return r; },
			  d: (t,alpha,a,b)=>{ let m=alpha.length, inv=Affine.modInv(a,m); if(inv===null)return "无解"; let r=""; for(let c of t){ let i=alpha.indexOf(c.toLowerCase()); if(i===-1) r+=c; else { let j = ((inv*(i-b))%m+m)%m; r+= c===c.toUpperCase()? alpha[j].toUpperCase() : alpha[j]; } } return r; }
			};
			
			
			function updateAll(){
			  let t = document.getElementById('mainInput').value;
			  if(!t){document.querySelectorAll('.result').forEach(el=>el.textContent=""); return;}
			  let s = parseInt(document.getElementById('caesarShift').value)||3;
			  document.getElementById('caesarResult').textContent = `加密: ${Caesar.e(t,s)}\n解密: ${Caesar.d(t,s)}`;
			  let k = document.getElementById('vigenereKey').value||"KEY";
			  document.getElementById('vigenereResult').textContent = `加密: ${Vigenere.e(t,k)}\n解密: ${Vigenere.d(t,k)}`;
			  let r = parseInt(document.getElementById('railCount').value)||3;
			  document.getElementById('railResult').textContent = `加密: ${RailFence.e(t,r)}\n解密: ${RailFence.d(t,r)}`;
			  let alpha = document.getElementById('AffineAlpha').value||"abcdefghijklmnopqrstuvwxyz";
			  let a = parseInt(document.getElementById('Affineslope').value)||1;
			  let b = parseInt(document.getElementById('AffineIntercept').value)||1;
			  document.getElementById('AffineResult').textContent = `加密: ${Affine.e(t,alpha,a,b)}\n解密: ${Affine.d(t,alpha,a,b)}`;

			}
			document.querySelectorAll('input, textarea').forEach(el=>el.addEventListener('input', updateAll));
			updateAll();
			
			// 旗语与盲文编码实现
			// 减小画布尺寸
			const SEMAPHORE_CANVAS_SIZE = 120; // 从200减小到120
			const BRAILLE_BOX_WIDTH = 90; // 从150减小到90
			const SCALE = SEMAPHORE_CANVAS_SIZE / 100;

			// 编码到字符的映射
			const semaphoreBitsToChar = "   W J#  YU T    RQ P   O        ML K   I       H                FE D   C       B               A                                ZX V           S               N                               G                                                               ";
			const brailleBitsToChar = " A C BIF E D HJG K M LSP O N RTQ              W  U X V   Z Y     ";

			const semaphoreMap = {};
			for (let i = 0; i < semaphoreBitsToChar.length; ++i) {
				if (semaphoreBitsToChar[i].trim()) semaphoreMap[i] = semaphoreBitsToChar[i];
			}

			const brailleMap = {};
			for (let i = 0; i < brailleBitsToChar.length; ++i) {
				if (brailleBitsToChar[i].trim()) brailleMap[i] = brailleBitsToChar[i];
			}

			// 字符到编码的映射
			const charToSemaphore = {};
			const charToBraille = {};

			for (const [key, value] of Object.entries(semaphoreMap)) {
				charToSemaphore[value] = parseInt(key);
			}

			for (const [key, value] of Object.entries(brailleMap)) {
				charToBraille[value] = parseInt(key);
			}

			// 当前编码位数组 - 为每个画布保存一个位值
			let currentBitsArray = [0];
			// 当前活动的画布索引
			let activeCanvasIndex = 0;

			// 创建画布容器并初始化
			function setupQiyuCanvas() {
				// 重置状态
				currentBitsArray = [0];
				activeCanvasIndex = 0;
				
				// 更新画布显示
				updateCanvasDisplay();
			}

			// 新增函数：更新画布显示
			function updateCanvasDisplay() {
				const container = document.getElementById('qiyuCanvasContainer');
				const type = document.getElementById('qiyuType').value;
				
				// 清空容器
				container.innerHTML = '';
				
				// 为每个位值创建画布
				for (let i = 0; i < currentBitsArray.length; i++) {
					// 创建画布容器
					const canvasWrapper = document.createElement('div');
					canvasWrapper.className = 'canvas-wrapper';
					canvasWrapper.style.position = 'relative';
					canvasWrapper.style.margin = '5px';
					
					// 创建画布
					const canvas = document.createElement('canvas');
					canvas.width = type === 'semaphore' ? SEMAPHORE_CANVAS_SIZE : BRAILLE_BOX_WIDTH;
					canvas.height = SEMAPHORE_CANVAS_SIZE;
					canvas.id = `${type}Canvas_${i}`;
					canvas.dataset.index = i;
					
					// 设置样式
					if (i === activeCanvasIndex) {
						canvas.style.opacity = '1';
						canvas.style.border = '2px solid #2ecc71';
					} else if (i < activeCanvasIndex) {
						canvas.style.opacity = '0.8';
						canvas.style.border = '1px solid #3498db';
					} else {
						canvas.style.opacity = '0.6';
						canvas.style.border = '1px dashed #3498db';
					}
					canvas.style.borderRadius = '8px';
					
					// 绘制背景
					if (type === 'semaphore') {
						drawSemaphoreBackground(canvas);
						if (currentBitsArray[i] > 0) {
							drawSemaphoreLines(canvas, currentBitsArray[i]);
						}
					} else {
						drawBrailleBackground(canvas);
						if (currentBitsArray[i] > 0) {
							drawBrailleDots(canvas, currentBitsArray[i]);
						}
					}
					
					// 添加点击事件
					canvas.addEventListener('click', function(e) {
						const idx = parseInt(this.dataset.index);
						// 设置当前活动画布
						activeCanvasIndex = idx;
						
						// 处理点击
						const rect = canvas.getBoundingClientRect();
						const x = e.clientX - rect.left;
						const y = e.clientY - rect.top;
						
						if (type === 'semaphore') {
							handleSemaphoreClick(canvas, x, y, idx);
						} else {
							handleBrailleClick(canvas, x, y, idx);
						}
						
						// 如果这是最后一个画布，添加新画布
						if (idx === currentBitsArray.length - 1) {
							currentBitsArray.push(0);
							updateCanvasDisplay(); // 更新整个显示
						}
						
						// 更新所有画布样式
						updateCanvasStyles();
					});
					
					// 添加序号标签
					const label = document.createElement('div');
					label.textContent = i + 1;
					label.style.position = 'absolute';
					label.style.bottom = '0';
					label.style.left = '0';
					label.style.backgroundColor = 'rgba(0,0,0,0.5)';
					label.style.color = 'white';
					label.style.padding = '2px 6px';
					label.style.borderBottomLeftRadius = '7px';
					label.style.fontSize = '10px';
					
					// 添加字符标签（如果有）
					if (currentBitsArray[i] > 0) {
						const mapToUse = type === 'semaphore' ? semaphoreMap : brailleMap;
						const char = mapToUse[currentBitsArray[i]];
						if (char) {
							const charLabel = document.createElement('div');
							charLabel.textContent = char;
							charLabel.style.position = 'absolute';
							charLabel.style.top = '0';
							charLabel.style.right = '0';
							charLabel.style.backgroundColor = 'rgba(0,0,0,0.5)';
							charLabel.style.color = 'white';
							charLabel.style.padding = '2px 6px';
							charLabel.style.borderTopRightRadius = '7px';
							charLabel.style.fontSize = '10px';
							canvasWrapper.appendChild(charLabel);
						}
					}
					
					canvasWrapper.appendChild(canvas);
					canvasWrapper.appendChild(label);
					container.appendChild(canvasWrapper);
				}
			}

			// 更新所有画布的样式
			function updateCanvasStyles() {
				const container = document.getElementById('qiyuCanvasContainer');
				const canvases = container.querySelectorAll('canvas');
				
				canvases.forEach(canvas => {
					const idx = parseInt(canvas.dataset.index);
					if (idx === activeCanvasIndex) {
						canvas.style.opacity = '1';
						canvas.style.border = '2px solid #2ecc71';
					} else if (idx < activeCanvasIndex) {
						canvas.style.opacity = '0.8';
						canvas.style.border = '1px solid #3498db';
					} else {
						canvas.style.opacity = '0.6';
						canvas.style.border = '1px dashed #3498db';
					}
				});
			}

			// 处理旗语画布点击 - 添加画布索引参数
			function handleSemaphoreClick(canvas, x, y, canvasIndex) {
				const dx = x - 50 * SCALE;
				const dy = y - 50 * SCALE;
				const r = dx * dx + dy * dy;
				
				if (r < 4 || r > SEMAPHORE_CANVAS_SIZE * SEMAPHORE_CANVAS_SIZE / 2) {
					return;
				}
				
				let ang = Math.atan2(-dy, dx) * 4 / Math.PI;
				let angr = Math.round(ang);
				if (angr < 0) {
					angr += 8;
				}
				
				// 切换该位
				const newBit = 1 << angr;
				if (currentBitsArray[canvasIndex] & newBit) {
					currentBitsArray[canvasIndex] &= ~newBit; // 清除该位
				} else {
					// 确保最多两个方向
					const bitCount = countBits(currentBitsArray[canvasIndex]);
					if (bitCount >= 2) {
						currentBitsArray[canvasIndex] = newBit; // 如果已有两个方向，重置为当前点击的方向
					} else {
						currentBitsArray[canvasIndex] |= newBit; // 添加当前方向
					}
				}
				
				// 重绘
				drawSemaphoreBackground(canvas);
				drawSemaphoreLines(canvas, currentBitsArray[canvasIndex]);
				
				// 更新结果
				updateQiyuResult(canvasIndex);
			}

			// 处理盲文画布点击 - 添加画布索引参数
			function handleBrailleClick(canvas, x, y, canvasIndex) {
				const dx = x - BRAILLE_BOX_WIDTH / 2;
				const dy = y;
				let angr = dx < 0 ? 0 : 1;
				
				if (dy < SEMAPHORE_CANVAS_SIZE / 3) {
					angr += 0;
				} else if (dy < 2 * SEMAPHORE_CANVAS_SIZE / 3) {
					angr += 2;
				} else {
					angr += 4;
				}
				
				// 切换该位
				currentBitsArray[canvasIndex] ^= (1 << angr);
				
				// 重绘
				drawBrailleBackground(canvas);
				drawBrailleDots(canvas, currentBitsArray[canvasIndex]);
				
				// 更新结果
				updateQiyuResult(canvasIndex);
			}

			// 更新旗语结果显示
			function updateQiyuResult(canvasIndex) {
				const type = document.getElementById('qiyuType').value;
				const map = type === 'semaphore' ? semaphoreMap : brailleMap;
				
				const bits = currentBitsArray[canvasIndex];
				const char = map[bits] || ' ';
				
				// 更新输入框
				updateInputFromCanvases();
				
				// 显示当前字符
				const result = document.getElementById('qiyuResult');
				result.textContent = `画布 ${canvasIndex + 1} 当前字符: ${char}`;
			}

			// 从所有画布更新输入框
			function updateInputFromCanvases() {
				const type = document.getElementById('qiyuType').value;
				const map = type === 'semaphore' ? semaphoreMap : brailleMap;
				
				let text = '';
				for (let i = 0; i < currentBitsArray.length; i++) {
					const bits = currentBitsArray[i];
					if (bits > 0 && map[bits]) {
						text += map[bits];
					}
				}
				
				document.getElementById('qiyuInput').value = text;
			}

			// 从输入框更新所有画布 - 修改这个函数
			function updateCanvasesFromInput() {
				const type = document.getElementById('qiyuType').value;
				const text = document.getElementById('qiyuInput').value.toUpperCase();
				const map = type === 'semaphore' ? charToSemaphore : charToBraille;
				
				// 清空当前数组
				currentBitsArray = [];
				
				// 为每个字符创建位值
				for (let i = 0; i < text.length; i++) {
					const char = text[i];
					if (map[char]) {
						currentBitsArray.push(map[char]);
					}
				}
				
				// 确保至少有一个元素
				if (currentBitsArray.length === 0) {
					currentBitsArray = [0];
				}
				
				// 添加一个空白画布用于后续输入
				currentBitsArray.push(0);
				
				// 重置活动画布到最后一个有内容的画布
				activeCanvasIndex = currentBitsArray.length - 2;
				if (activeCanvasIndex < 0) activeCanvasIndex = 0;
				
				// 重新创建所有画布 - 不要调用setupQiyuCanvas()，因为它会重置所有状态
				// 而是直接更新现有画布或添加新画布
				updateCanvasDisplay();
			}

			// 添加清空按钮功能
			document.getElementById('qiyuClear').addEventListener('click', function() {
				document.getElementById('qiyuInput').value = '';
				setupQiyuCanvas(); // 重新初始化画布
				document.getElementById('qiyuResult').textContent = '';
			});

			// 修改处理输入框变化的函数，使其能够立即响应
			document.getElementById('qiyuInput').addEventListener('input', function() {
				updateCanvasesFromInput();
				document.getElementById('qiyuResult').textContent = ''; // 清空结果显示
			});

			// 监听类型切换
			document.getElementById('qiyuType').addEventListener('change', function() {
				setupQiyuCanvas(); // 重新初始化画布
			});

			// 初始化
			document.addEventListener('DOMContentLoaded', function() {
				setupQiyuCanvas();
			});
			
			// 绘制旗语背景 - 提高可见度和高科技感
			function drawSemaphoreBackground(canvas) {
				const ctx = canvas.getContext('2d');
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				
				// 深色背景，带有网格感
				ctx.fillStyle = '#0f1b33';
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				
				// 添加格子线纹理
				ctx.beginPath();
				ctx.strokeStyle = 'rgba(52, 152, 219, 0.15)';
				ctx.lineWidth = 0.5;
				
				// 横线
				for(let i = 0; i < canvas.height; i += 10) {
					ctx.moveTo(0, i);
					ctx.lineTo(canvas.width, i);
				}
				
				// 竖线
				for(let i = 0; i < canvas.width; i += 10) {
					ctx.moveTo(i, 0);
					ctx.lineTo(i, canvas.height);
				}
				ctx.stroke();
				
				// 绘制八个方向轴线
				const pts = [[90, 50], [78, 22], [50, 10], [22, 22], [10, 50], [22, 78], [50, 90], [78, 78]];
				ctx.beginPath();
				
				for (const coord of pts) {
					ctx.moveTo(50 * SCALE, 50 * SCALE);
					ctx.lineTo(coord[0] * SCALE, coord[1] * SCALE);
					ctx.strokeStyle = '#1e88e5'; // 亮蓝色替代暗色
					ctx.lineWidth = 1.5;
				}
				ctx.stroke();
				
				// 绘制中心点
				ctx.beginPath();
				ctx.arc(50 * SCALE, 50 * SCALE, 4, 0, 2 * Math.PI);
				ctx.fillStyle = '#2ecc71'; // 绿色中心点
				ctx.fill();
				
				// 添加外圈辉光
				ctx.beginPath();
				ctx.arc(50 * SCALE, 50 * SCALE, 6, 0, 2 * Math.PI);
				ctx.strokeStyle = '#2ecc71';
				ctx.lineWidth = 1;
				ctx.stroke();
			}

			// 绘制旗语线条 - 更明显的高科技效果
			function drawSemaphoreLines(canvas, bits) {
				const ctx = canvas.getContext('2d');
				const pts = [[90, 50], [78, 22], [50, 10], [22, 22], [10, 50], [22, 78], [50, 90], [78, 78]];
				
				// 给激活的线条添加辉光效果
				for (let i = 0; i < 8; i++) {
					if (bits & (1 << i)) {
						// 明亮的辉光层
						ctx.beginPath();
						ctx.moveTo(50 * SCALE, 50 * SCALE);
						ctx.lineTo(pts[i][0] * SCALE, pts[i][1] * SCALE);
						ctx.strokeStyle = "rgba(46, 204, 113, 0.4)"; // 绿色辉光
						ctx.lineWidth = 8;
						ctx.stroke();
					}
				}
				
				// 绘制主线条
				ctx.beginPath();
				for (let i = 0; i < 8; i++) {
					if (bits & (1 << i)) {
						ctx.moveTo(50 * SCALE, 50 * SCALE);
						ctx.lineTo(pts[i][0] * SCALE, pts[i][1] * SCALE);
					}
				}
				
				// 使用更鲜艳的渐变
				const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
				gradient.addColorStop(0, '#00bcd4'); // 亮青色
				gradient.addColorStop(1, '#2ecc71'); // 亮绿色
				ctx.strokeStyle = gradient;
				ctx.lineWidth = 3;
				ctx.stroke();
				
				// 在线末端添加圆点
				for (let i = 0; i < 8; i++) {
					if (bits & (1 << i)) {
						ctx.beginPath();
						ctx.arc(pts[i][0] * SCALE, pts[i][1] * SCALE, 3, 0, 2 * Math.PI);
						ctx.fillStyle = '#2ecc71';
						ctx.fill();
					}
				}
			}

			// 绘制盲文背景 - 提高可见度
			function drawBrailleBackground(canvas) {
				const ctx = canvas.getContext('2d');
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				
				// 深色背景
				ctx.fillStyle = '#0f1b33';
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				
				// 添加格子线纹理
				ctx.beginPath();
				ctx.strokeStyle = 'rgba(52, 152, 219, 0.15)';
				ctx.lineWidth = 0.5;
				
				// 横线
				for(let i = 0; i < canvas.height; i += 10) {
					ctx.moveTo(0, i);
					ctx.lineTo(canvas.width, i);
				}
				
				// 竖线
				for(let i = 0; i < canvas.width; i += 10) {
					ctx.moveTo(i, 0);
					ctx.lineTo(i, canvas.height);
				}
				ctx.stroke();
				
				const xOffset = 24;
				const pts = [[xOffset, 15], [100 - xOffset, 15], [xOffset, 50], [100 - xOffset, 50], [xOffset, 85], [100 - xOffset, 85]];
				
				for (let i = 0; i < pts.length; ++i) {
					ctx.beginPath();
					ctx.arc(pts[i][0] / 100 * canvas.width, pts[i][1] * SCALE, 7 * SCALE, 0, 2 * Math.PI, false);
					ctx.lineWidth = 1.5;
					ctx.strokeStyle = '#3498db'; // 明亮的蓝色
					ctx.stroke();
					
					// 有明显的内部填充
					ctx.fillStyle = 'rgba(52, 152, 219, 0.15)'; // 蓝色半透明填充
					ctx.fill();
				}
			}

			// 绘制盲文点 - 更鲜明的视觉效果
			function drawBrailleDots(canvas, bits) {
				const ctx = canvas.getContext('2d');
				const xOffset = 24;
				const pts = [[xOffset, 15], [100 - xOffset, 15], [xOffset, 50], [100 - xOffset, 50], [xOffset, 85], [100 - xOffset, 85]];
				
				// 首先绘制所有点的轮廓
				for (let i = 0; i < pts.length; ++i) {
					ctx.beginPath();
					ctx.arc(pts[i][0] / 100 * canvas.width, pts[i][1] * SCALE, 7 * SCALE, 0, 2 * Math.PI, false);
					ctx.lineWidth = 1.5;
					ctx.strokeStyle = bits & (1 << i) ? '#2ecc71' : '#3498db';
					ctx.stroke();
				}
				
				// 然后绘制激活的点
				for (let i = 0; i < pts.length; ++i) {
					if (bits & (1 << i)) {
						// 添加发光效果
						ctx.beginPath();
						ctx.arc(pts[i][0] / 100 * canvas.width, pts[i][1] * SCALE, 9 * SCALE, 0, 2 * Math.PI, false);
						ctx.fillStyle = 'rgba(46, 204, 113, 0.2)';
						ctx.fill();
						
						// 绘制点
						ctx.beginPath();
						ctx.arc(pts[i][0] / 100 * canvas.width, pts[i][1] * SCALE, 7 * SCALE, 0, 2 * Math.PI, false);
						
						// 使用渐变填充
						const dotGradient = ctx.createRadialGradient(
							pts[i][0] / 100 * canvas.width, pts[i][1] * SCALE, 0,
							pts[i][0] / 100 * canvas.width, pts[i][1] * SCALE, 7 * SCALE
						);
						dotGradient.addColorStop(0, '#2ecc71'); // 明亮的绿色中心
						dotGradient.addColorStop(1, '#00bcd4'); // 亮青色边缘
						ctx.fillStyle = dotGradient;
						ctx.fill();
						
						// 添加高光点
						ctx.beginPath();
						ctx.arc(
							pts[i][0] / 100 * canvas.width - 2, 
							pts[i][1] * SCALE - 2, 
							2, 0, 2 * Math.PI, false
						);
						ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
						ctx.fill();
					}
				}
			}

			// 计算二进制位中1的个数
			function countBits(n) {
				let count = 0;
				while (n) {
					count += n & 1;
					n >>= 1;
				}
				return count;
			}
			
		</script>

	</body>
</html>